<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="【算法】Min_25筛"><meta name="keywords" content=""><meta name="author" content="GaryZhong"><meta name="copyright" content="GaryZhong"><title>【算法】Min_25筛 | GaryZhong's EZ Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 5.0.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-0-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6Min-25%E7%AD%9B%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">Part 0 - 为什么要学Min_25筛？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-1-Min-25%E7%AD%9B%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">2.</span> <span class="toc-text">Part 1 - Min_25筛基本思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E9%80%92%E6%8E%A8%E8%AE%B2%E8%B5%B7"><span class="toc-number">2.1.</span> <span class="toc-text">从一个奇怪的递推讲起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">回归积性函数求和问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-2-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">Part 2 - 程序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#g%E7%9A%84%E6%B1%82%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">g的求法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#s%E7%9A%84%E6%B1%82%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">s的求法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">3.3.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">GaryZhong</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">GaryZhong's EZ Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">【算法】Min_25筛</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Part-0-为什么要学Min-25筛？"><a href="#Part-0-为什么要学Min-25筛？" class="headerlink" title="Part 0 - 为什么要学Min_25筛？"></a>Part 0 - 为什么要学Min_25筛？</h2><p>Min_25筛是一种用于求积性函数前缀和的算法。然而还有一种算法叫做”杜教筛”也能达到求积性函数前缀和的目的，那么为什么要学Min_25筛呢？</p>
<p>回头去看杜教筛的过程，容易发现：</p>
<ul>
<li>$\mu(n)$能够用杜教筛求前缀和，因为它有性质：</li>
</ul>
<script type="math/tex; mode=display">
\sum_{d|n}\mu(d)=[n=1]</script><ul>
<li>$\phi(n)$能够用杜教筛求前缀和，因为它有性质：</li>
</ul>
<script type="math/tex; mode=display">
\sum_{d|n}\phi(d)=n</script><p>如果给出的积性函数$f(n)$并不具有上述这种优美的性质，用杜教筛求前缀和就略显困难了.</p>
<p>而如果积性函数$F(n)$满足（下文中$p$均表示一质数）：</p>
<ul>
<li>$F(p)$是一个关于$p$的简单多项式.</li>
<li>$F(p^c)$可以快速求得.</li>
</ul>
<p>这时Min_25筛就能对$f(n)$快速求得前缀和。可以发现，Min_25筛的适用情况远比杜教筛要普遍。LOJ上面的<a target="_blank" rel="noopener" href="https://loj.ac/problem/6053">这道例题</a>就是一个不适用杜教筛而适用Min_25筛的例子.</p>
<h2 id="Part-1-Min-25筛基本思想"><a href="#Part-1-Min-25筛基本思想" class="headerlink" title="Part 1 - Min_25筛基本思想"></a>Part 1 - Min_25筛基本思想</h2><h3 id="从一个奇怪的递推讲起"><a href="#从一个奇怪的递推讲起" class="headerlink" title="从一个奇怪的递推讲起"></a>从一个奇怪的递推讲起</h3><p>引入一些符号：</p>
<ul>
<li>$P$：全体质数组成的集合.</li>
<li>$P_i$：第$i$小的质数.</li>
<li>$minp(x)$：$x$的最小质因子，$x=1$时令其为$1$.</li>
<li>$f(i)$：一个<strong>完全积性函数</strong>.</li>
</ul>
<p>定义$g(n,j)$如下：</p>
<script type="math/tex; mode=display">
g(n,j)=\sum_{i=1}^{n}[i\in P\ or\ minp(i)>P_j]f(i)</script><p>即对$[1,n]$之内，满足$i$是质数或$i$的最小质因子$&gt;P_j$的$i$，求它们$f(i)$的和.</p>
<hr>
<p>现在我们来推一推这个$g(n,j)$的递推式.</p>
<ul>
<li>$P_j^2&gt;n$</li>
</ul>
<p>$g(n,j-1)$统计了$[1,n]$中所有的质数$i$，以及$minp(i)&gt;P_{j-1}$的$i$，要从其递推到$g(n,j-1)$，只需减去$minp(i)=P_j$的所有合数$i$（$[1,n]$中质数贡献不应减去）。这样的合数最小是$P_j^2$，因此$P_j^2&gt;n$时，无需从$g(n,j-1)$减去任何贡献。此时$g(n,j)=g(n,j-1)$.</p>
<ul>
<li>$P_j^2\le n$</li>
</ul>
<p>这时就要统计$minp(i)=P_j$的所有合数$i$的贡献了。考虑在$g(\lfloor \frac{n}{P_j} \rfloor,j-1)$统计的$i$中，我们先中减去$minp(i)\leq P_{j-1}$的，那么剩余的都是$minp(i)&gt; P_{j-1}$的.</p>
<p>满足$minp(i)&gt;P_{j-1}$却不一定满足$minp(i)=P_j$。为了使$minp(i)=P_j$我们给每个$minp(i)&gt;P_{j-1}$的$i$都乘上一个$P_j$，这样就能保证其最小质因子为$P_j$了，可以发现这样统计刚好算出了$[1,n]$之内$minp(i)=P_j$的所有合数$i$的贡献。此时</p>
<script type="math/tex; mode=display">
g(n,j)=g(n,j-1)-f(P_j)(g(\lfloor \frac{n}{P_j} \rfloor,j-1)-\sum_{i=1}^{j-1}f(P_i))</script><p>根据定义可以发现，$g(\lfloor \frac{n}{P_j} \rfloor,j-1)$统计的$i$中$minp(i)\leq P_{j-1}$的其实就是$1\sim j-1$的质数，所以把这些质数的贡献减掉，就得到了$minp(i)&gt; P_{j-1}$的$i$的贡献；给这些数乘上$P_j$后，它们刚好组成了$[1,n]$中$minp(i)=P_j$的合数。由完全积性函数的性质，一个数$i$乘上$P_j$后其函数值$f(iP_j)=f(i)f(P_j)$，即函数值乘上$f(P_j)$，因此得到上面的递推式.</p>
<p>综上$g(n,j)$的递推式就是：</p>
<script type="math/tex; mode=display">
g(n,j)=\begin{cases}
g(n,j-1) & P_j^2\gt n \\
g(n,j)=g(n,j-1)-f(P_j)(g(\lfloor \frac{n}{P_j} \rfloor,j-1)-\sum_{i=1}^{j-1}f(P_i)) & P_j^2\leq n
\end{cases}</script><hr>
<p>所以，为什么要求$g(n,j)$？</p>
<p>设$x$为满足$P_x^2\leq n$的最大的$x$，因为$[1,n]$内不存在$minp(i)&gt;P_x$的合数$i$，所以有</p>
<script type="math/tex; mode=display">
g(n,x)=\sum_{i=1}^{n}[i\in P\ or\ minp(i)>P_x]f(i)=\sum_{i=1}^{n}[i\in P]f(i)=\sum_{i=1}^{x}f(P_i)</script><p>即我们利用$g$状态的递推，求出$[1,n]$之内每个质数$i$的$f(i)$的和，前提是$f(i)$为<strong>完全积性函数</strong>.</p>
<p>那么，如何利用它来求积性函数的前缀和呢？</p>
<h3 id="回归积性函数求和问题"><a href="#回归积性函数求和问题" class="headerlink" title="回归积性函数求和问题"></a>回归积性函数求和问题</h3><p>设</p>
<script type="math/tex; mode=display">
s(n,j)=\sum_{i=1}^{n}[minp(i)\ge P_j]f(i)</script><p>即对$[1,n]$内最小质因子$\ge P_j$的$i$求$f(i)$的和，这里的$f(i)$是一个<strong>积性函数</strong>而不一定是<strong>完全积性函数</strong>.</p>
<p>参照递推$g$的思想，我们分开统计质数合数，得到$s$的递推式（$x$为满足$P_x^2\leq n$的最大的$x$）：</p>
<script type="math/tex; mode=display">
s(n,j)=\sum_{i=1}^{x}f(P_i)-\sum_{i=1}^{j-1}f(P_i)+\sum_{k=j}^{P_k^2\leq n}\sum_{e=1}^{P_k^{e+1}\leq n}(f(P_k^e)s(\lfloor \frac{n}{P_k^e} \rfloor,k+1)+f(P_k^{e+1}))</script><p>前面部分计算的就是$P_{j\sim x}$的$f(P_i)$之和，计算了质数贡献。而后面部分就是枚举合数的最小质因子，再枚举最小质因子的指数；然而这样会漏算合数$P_k^{e+1}$，再加上即可.</p>
<hr>
<p>所以，为什么要求$s(n,j)$？</p>
<p>根据定义有</p>
<script type="math/tex; mode=display">
s(n,1)=\sum_{i=1}^{n}[minp(i)\ge P_1]f(i)=\sum_{i=2}^{n}f(i) \\
s(n,1)+f(1)=\sum_{i=1}^{n}f(i)</script><p>即利用$s$的递推我们能求出$[1,n]$所有$i$的$f(i)$之和。这样看似完成了积性函数求和问题，但是复杂度并不正确，因为我们还没有利用上面求的$g$.</p>
<hr>
<p>观察$s$的递推式，发现下面这个部分在$f(i)$为<strong>完全积性函数</strong>时是可以用预处理的$g$快速求出的：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{x}f(P_i)=g(n,x)</script><p>现在问题在于，$f(i)$仅满足<strong>积性函数</strong>的性质，是否有办法使其也满足<strong>完全积性函数</strong>的性质？</p>
<p>其实在Min_25筛最初对$f(i)$的假设中，有一个条件我们还没有利用：</p>
<ul>
<li>$f(p)$能表示为关于$p$的多项式.</li>
</ul>
<p>假设$f(p)=p^k$，这时$f(p)$就是个<strong>完全积性函数</strong>，$s$的递推式就是：</p>
<script type="math/tex; mode=display">
s(n,j)=g(n,x)-\sum_{i=1}^{j-1}f(P_i)+\sum_{k=j}^{P_k^2\leq n}\sum_{e=1}^{P_k^{e+1}\leq n}(f(P_k^e)s(\lfloor \frac{n}{P_k^e} \rfloor,k+1)+f(P_k^{e+1}))</script><p>那要是$f(p)=ap^k$？$a$是公因式，可以直接提出来，和上面的求法并没有区别.</p>
<p>如果$f(p)=a_0+a_1p^1+a_2p^2+…$？直接拆成$a_0$求和、$a_1p^1$求和、$a_2p^2$求和、以此类推。即对这样的<strong>积性函数</strong>$f(p)$求和，可以拆成对若干个<strong>完全积性函数</strong>的求和。$s$的递推式可以写成：</p>
<script type="math/tex; mode=display">
s(n,j)=\sum_{i=0}^{k}a_ig_i(n,x)-\sum_{i=1}^{j-1}f(P_i)+\sum_{k=j}^{P_k^2\leq n}\sum_{e=1}^{P_k^{e+1}\leq n}(f(P_k^e)s(\lfloor \frac{n}{P_k^e} \rfloor,k+1)+f(P_k^{e+1}))</script><p>通过这一系列复杂推导，我们就能够结合$g,s$求出积性函数的前缀和.</p>
<h2 id="Part-2-程序实现"><a href="#Part-2-程序实现" class="headerlink" title="Part 2 - 程序实现"></a>Part 2 - 程序实现</h2><h3 id="g的求法"><a href="#g的求法" class="headerlink" title="g的求法"></a>g的求法</h3><p>首先根据$g$的定义可以直接算出所有$g(n,0)$.</p>
<p>如果直接开个数组存$g(n,j)$，空间是$O(n\sqrt{n})$的，太大了。注意到$\lfloor \frac{\lfloor \frac{n}{a} \rfloor}{b} \rfloor=\lfloor \frac{n}{ab} \rfloor$，所以$g(x,j)$中会被用到的$x$其实就是所有的$\lfloor \frac{n}{i} \rfloor$，而这些数的个数是$O(\sqrt{n})$级别的，如果再将第二维$j$滚动处理，就能做到$O(\sqrt{n})$的空间.</p>
<p>具体实现方法就是，先整除分块算出所有$\lfloor \frac{n}{i} \rfloor$，将它们离散化（分别对应一个编号）.</p>
<p>这样做的过程被证明为$O(\frac{n^{\frac{3}{4}}}{logn})$的.</p>
<h3 id="s的求法"><a href="#s的求法" class="headerlink" title="s的求法"></a>s的求法</h3><p>预处理要用到的$g$之后，直接递归求解即可.</p>
<p>这样做的过程同样被证明为$O(\frac{n^{\frac{3}{4}}}{logn})$的.</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p>$\phi(p)=p-1,\mu(p)=-1$，它们都是满足Min_25筛要求的积性函数.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://loj.ac/problem/6053">LOJ例题</a>，这里的函数$f(p)=p \oplus 1$，可以发现$p&gt;2$时$f(p)=p-1$而$p=2$时$f(p)=3$，只需在求$s$的递归函数里稍作修改即可.</p>
</li>
</ol>
<p>给出例题代码便于理解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">400007</span>;</span><br><span class="line"><span class="keyword">const</span> ll mo=<span class="number">1000000007</span>,iv2=<span class="number">500000004</span>;</span><br><span class="line"></span><br><span class="line">ll n,g[N],h[N],w[N],sp[N],pr[N];</span><br><span class="line"><span class="keyword">int</span> rt,m,id[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> x&lt;=rt?id[<span class="number">0</span>][x]:id[<span class="number">1</span>][n/x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot,check[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preprime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check[i])pr[++tot]=i,sp[tot]=(sp[tot<span class="number">-1</span>]+i)%mo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*pr[j]&gt;n)<span class="keyword">break</span>;</span><br><span class="line">            check[i*pr[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pr[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">s</span><span class="params">(ll x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||pr[y]&gt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k=find(x); <span class="comment">//找到离散化后的编号</span></span><br><span class="line">    ll res=(h[k]-g[k]-sp[y<span class="number">-1</span>]+y<span class="number">-1</span>)%mo;res=(res+mo)%mo;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span>)res=(res+<span class="number">2</span>)%mo; <span class="comment">//y=1时会把2的贡献从3算错成1,加上2即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&lt;=tot&amp;&amp;pr[i]*pr[i]&lt;=x;++i)&#123;</span><br><span class="line">        ll mtp=pr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e=<span class="number">1</span>;mtp*pr[i]&lt;=x;++e,mtp*=pr[i])res=(res+s(x/mtp,i+<span class="number">1</span>)*(pr[i]^e)+(pr[i]^(e+<span class="number">1</span>)))%mo; <span class="comment">//此处参照s的递推式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;func.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n),rt=<span class="built_in">sqrt</span>(n),preprime(rt); <span class="comment">//先线性筛出sqrt(n)范围内的质数</span></span><br><span class="line">    <span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=n/(n/l),w[++m]=n/l;</span><br><span class="line">        <span class="keyword">if</span>(w[m]&lt;=rt)id[<span class="number">0</span>][w[m]]=m;</span><br><span class="line">        <span class="keyword">else</span> id[<span class="number">1</span>][n/w[m]]=m; <span class="comment">//这里是一种特殊的离散化</span></span><br><span class="line">        g[m]=(w[m]<span class="number">-1</span>)%mo; <span class="comment">//这里是g(n,0),对f(p)=p-1的1求和</span></span><br><span class="line">        h[m]=(w[m]+<span class="number">2</span>)%mo*((w[m]<span class="number">-1</span>)%mo)%mo*iv2%mo; <span class="comment">//这里是g(n,0),对f(p)=p-1的p求和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,k;i&lt;=m&amp;&amp;pr[j]*pr[j]&lt;=w[i];++i)&#123;</span><br><span class="line">            k=find(w[i]/pr[j]); <span class="comment">//找到离散化后其对应的编号</span></span><br><span class="line">            g[i]=(g[i]-g[k]+j<span class="number">-1</span>)%mo,g[i]=(g[i]+mo)%mo;</span><br><span class="line">            h[i]=(h[i]-pr[j]*(h[k]-sp[j<span class="number">-1</span>])%mo)%mo,h[i]=(h[i]+mo)%mo; <span class="comment">//此处参照g(n,j)的递推式</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(s(n,<span class="number">1</span>)+<span class="number">1</span>)%mo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GaryZhong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://zjloijr.github.io/2020/08/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Min-25%E7%AD%9B/">http://zjloijr.github.io/2020/08/04/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Min-25%E7%AD%9B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zjloijr.github.io">GaryZhong's EZ Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/11/%E3%80%90JZOJ6775%E3%80%91path/"><i class="fa fa-chevron-left">  </i><span>【JZOJ6775】path</span></a></div><div class="next-post pull-right"><a href="/2020/07/30/%E3%80%90JZOJ6772%E3%80%91prob/"><span>【JZOJ6772】prob</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By GaryZhong</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>